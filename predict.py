# -*- coding: utf-8 -*-
"""Copy of regresion-prediction_stock_prices.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/193LDXhDAtIF6yD59ekIJJdMqoBpDmJ-T

#Read in data
"""
import sys
import csv
import scipy
import numpy
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import Sequential, layers, callbacks
from tensorflow.keras.layers import Dense, LSTM, Dropout, GRU, Bidirectional
import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from matplotlib import pyplot as plt
from IPython.core.pylabtools import figsize
from pandas.plotting import register_matplotlib_converters
register_matplotlib_converters()
import seaborn as sns

if len(sys.argv) <= 1:
    exit("Too less arguments calling script")


model_lstm = keras.models.load_model("my_model")
input = pd.read_csv(sys.argv[1], header = 0)
TIME_STEPS = 30


def create_dataset (X, time_steps = 1):
    Xs = []
    for i in range(len(X)-time_steps):
        v = X[i:i+time_steps, :]
        Xs.append(v)
    return np.array(Xs)

def predict(model, input_data):
    dataset = input_data
    dataset = dataset.replace(",", "", regex=True)
    dataset = dataset.rename(columns = {'Data': 'Date'} )
    dataset["Date"]= pd.to_datetime(dataset["Date"])
    dataset['High'] = dataset['High'].astype('float32')
    dataset['Open'] = dataset['Open'].astype('float32')
    dataset['Low'] = dataset['Low'].astype('float32')
    dataset['Close'] = dataset['Close'].astype('float32')
    dataset['Volume'] = dataset['Volume'].astype('float32')
    X_test = dataset.drop(['Close','Date'], axis = 1)
    scaler_x = MinMaxScaler(feature_range = (0,1))
    scaler_y = MinMaxScaler(feature_range = (0,1))
    input_close = dataset.loc[:,['Close']].to_numpy()
    output_scaler = scaler_y.fit(input_close)

    input_scaler = scaler_x.fit(X_test)
    test_x_norm = input_scaler.transform(X_test)
    X_test = create_dataset(test_x_norm, TIME_STEPS)
    prediction = model.predict(X_test)
    prediction = output_scaler.inverse_transform(prediction)
    return prediction


result = predict(model_lstm, input)
print(result)
